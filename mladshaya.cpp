#include <iostream> // библиотека для ввода
#include <deque>    // библиотека с деком - двусторонний контейнер, все может
#include <stack>    // библиотека со стеком - доставать из верхушки, добавлять на верхушку
#include <queue>    // библиотека с очередью - доставать из начала, добавлять в конец
#include <vector>   // библиотека с вектором - массив, но умный
#include <string>   // библиотека со строкой - текст

using namespace std;

signed main() { 
    setlocale(LC_ALL, "RU");

    // пример работы с массивами
    // чтобы создать массив (вектор) нужно оформить вот такую конструкцию
    // vector <тип данных> название(размер, чем заполнить);
    // размер и чем заполнять можно не указывать
    int n;
    cout << "Введите размер массива: ";
    cin >> n; // вводим размер массива
    
    vector <int> v(n);
    // массив - это по сути большой набор переменных, которые удобно пронумерованы. 
    // создать массив целых чисел int размера n - значит создать n переменных. 
    // их названия - v[0], v[1] ... v[n - 1]. 
    // то есть конструкция обращения к переменной: название_вектора[номер_переменной]

    // с таким знанием массив можно ввести с клавиатуры: 
    // запускаем циклик, который перебирает номер переменной и вводит ее.
    cout << "Введите cам массив: ";
    for (int i = 0; i < n; ++i) {
        cin >> v[i];
    }

    // теперь выведем то, что получилось
    for (int i = 0; i < n; ++i) {
        cout << v[i] << " "; 
        // не забываем вывести пробел, чтобы разделить между собой числа
    }

    // в конце выведем символ перевода строчки.
    cout << "\n";
    // можно писать cout << endl; endl - расшифровывается как endline,
    // т.е конец строки по английски.

    // возможности вектора позволяют добавить элемент в конец или удалить его из конца.
    v.push_back(179);
    v.pop_back();
    // тут я добавил число 179 и потом удалил его обратно.
    
    // можно, например, добавить в конец массива его первый элемент. 
    v.push_back(v[0]);
    
    // поглядим, что получилось
    for (int i = 0; i < v.size(); ++i) { // v.size() - размер массива. сейчас он равен n+1,
                                         // так как мы добавили в массив 1 элемент.
        cout << v[i] << " ";
    }
    cout << "\n";


    cout << "\n\n\n";

    {
    // теперь немного про дек
    // он почти такой же, как и вектор.
    deque <int> dq(n);
    cout << "Введите элементы дека: ";
    for (int i = 0; i < n; ++i) {
        cin >> dq[i];
    }
    // его так же можно ввести

    // отличие от вектора заключается в наличии команд push_front(элемент), pop_front()
    // по аналогии с вектором, добавим последний элемент в начало, а начальный в конец

    int first = dq[0];
    int last  = dq[n - 1];
    dq.push_front(last);
    dq.push_back(first);
    
    for (int i = 0; i < dq.size(); ++i) {
        cout << dq[i] << " ";
    }
    cout << "\n";

    cout << "\n\n\n";



    // поговорим про очередь и стек. они совсем одинаковые в их использовании:
    // stack <тип данных> название; РАЗМЕР УКАЗАТЬ НЕЛЬЗЯ
    // queue <тип данных> название; РАЗМЕР УКАЗАТЬ НЕЛЬЗЯ
    stack <string> st; 
    queue <string> q;
    // для разнообразия создадим структурки, которые в себе хранят строчки
    st.push("a");
    st.push("ab");
    st.push("abc");
    q.push("a");
    q.push("ab");
    q.push("abc");
    // добавили в обе структуры строчки a, ab, abc. 
    
    // теперь если считать, что начало очереди слева, то очередь будет выглядеть как
    // a ab abc - так как a "пришла" первой, а "abc" - последней. 
    // в очереди добавленные элементы встают в конец.
    
    // в стеке добавление тоже происходит в конец, поэтому стек будет выглядеть так же, 
    // если считать, что верхушка стека справа

    // теперь удалим элемент. 
    st.pop();
    q.pop();

    // из очереди удалится самый левый элемент, то есть первый прибывший.
    // очередь будет выглядеть как: ab abc

    // а из стека удалится последний добавленный, то есть самый правый элемент
    // стек будет выглядеть как: a ab

    // а теперь умом жестким почистим очередь и стек. в векторе и деке есть метод v.clear(),
    // а в стеке и очереди придется повозиться

    while (!st.empty()) { // т.е пока st.size() != 0
        st.pop();
    }

    while (!q.empty()) {
        q.pop();
    }

    }



    // в задаче про ПСП, чтобы ввести скобочки, нужно использовать строку - string. 
    // чтобы создать строчку, нужна такая конструкция:
    // string название; можно строчке сразу присвоить значение.
    string s = "aboba";
    
    // строчки удобны тем, что их легко вводить. 
    cin >> s;
    // введется текст до первого пробела или перевода строки

    // строчка - как вектор символов, можно обращаться по индексу, то есть писать s[i].
    // пусть нам ввели скобочную последовательность. поработаем с ней немного.
    for (int i = 0; i < s.size(); ++i) {
        if (s[i] == '(' || s[i] == '{' || s[i] == '[') { // вот этот оператор || обозначает "или"
                                                         // то есть условие выполнится в случае, когда s[i]
                                                         // является одной из трех открывающихся скобок
            // в задаче про ПСП надо было бы запихнуть эту скобку в стек.
        } else {
            if (s[i] == ')') {

            } else if (s[i] == '}') {

            } else if (s[i] == ']') {

            }
            // а в этих трех ифах надо было бы поработать с верхушкой стека.
        }
    }



    // теперь немного про задачу пьяница. я планирую это дело порассказывать у доски,
    // а тут добавлю пример ввода и план кода.
    deque <int> first(5), second(5);
    for (int i = 0; i < 5; ++i) {
        cin >> first[i];
    }
    for (int i = 0; i < 5; ++i) {
        cin >> second[i];
    }
    for (int i = 0; i < 1000000; ++i) { // перебираем ход игры. до 10^6, как и просят в задаче.
        int card_first = first[0];
        int card_second = second[0];
        first.pop_front();
        second.pop_front();
        if (true) { // вот тут вместо условия подставить проверку на то, 
                    // бьет ли первый игрок второго своей картой

            // а тут запихнуть в нужный дек сзади в нужном порядке числа card_first, card_second.
        } else {
            // а тут запихнуть в нужный дек сзади в нужном порядке числа card_first, card_second.
        }
    }
}
